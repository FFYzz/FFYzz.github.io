<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/timg.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon64.png">
  <link rel="mask-icon" href="/images/icon64.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ffyzz.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="HandlerMapping 在 SpringMVC 中的作用简而言之就是根据请求，找到对应的处理器。 HandlerMapping 算是 SpringMVC 中最重要的一个组件之一了。">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC 组件-HandlerMapping">
<meta property="og:url" content="https://ffyzz.github.io/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerMapping/index.html">
<meta property="og:site_name" content="Journey">
<meta property="og:description" content="HandlerMapping 在 SpringMVC 中的作用简而言之就是根据请求，找到对应的处理器。 HandlerMapping 算是 SpringMVC 中最重要的一个组件之一了。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/9be02752gy1gl2vroydvcj20rs0ae436.jpg">
<meta property="article:published_time" content="2020-11-21T12:02:28.000Z">
<meta property="article:modified_time" content="2020-11-28T06:12:15.399Z">
<meta property="article:author" content="FFYzz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/9be02752gy1gl2vroydvcj20rs0ae436.jpg">

<link rel="canonical" href="https://ffyzz.github.io/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerMapping/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringMVC 组件-HandlerMapping | Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ffyzz.github.io/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerMapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FFYzz">
      <meta itemprop="description" content="在自我鄙视中一步一步往上爬">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringMVC 组件-HandlerMapping
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 20:02:28" itemprop="dateCreated datePublished" datetime="2020-11-21T20:02:28+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 14:12:15" itemprop="dateModified" datetime="2020-11-28T14:12:15+08:00">2020-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerMapping/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/11/21/SpringMVC-组件-HandlerMapping/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>HandlerMapping 在 SpringMVC 中的作用简而言之就是根据请求，找到对应的处理器。 HandlerMapping 算是 SpringMVC 中最重要的一个组件之一了。</p>
<a id="more"></a>

<h2 id="HandlerMapping-的初始化"><a href="#HandlerMapping-的初始化" class="headerlink" title="HandlerMapping 的初始化"></a>HandlerMapping 的初始化</h2><p>本小节将介绍 HandlerMapping 的加载方式。首先把初始化 HandlerMapping 的方法丢上来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">        <span class="comment">// 查找所有的 HandlerMapping ，包括祖先中的 HandlerMapping</span></span><br><span class="line">        <span class="comment">// 依赖查找</span></span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">            <span class="comment">// 排个序</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 依赖查找，先查找是否在配置文件中有定义 handlerMapping</span></span><br><span class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">            <span class="comment">// 找不到或者找到了多个，不处理，后续会创建默认的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">    <span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">    <span class="comment">// 如果还没有 handlerMapping</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个默认的</span></span><br><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动 WebApplicationContext 容器的最后阶段，会通过发布一个 ContextRefreshedEvent 事件，最终回调到 DispatcherServlet#initStrategies 方法，对组件进行加载。<br>首先，根据属性 detectAllHandlerMappings，来决定是否加载所有的 HandlerMapping。默认为 true。但是我们可以通过配置参数，来改变其初始化的行为。修改配置的方式为在 web.xml 中对 DispatcherServlet 这个 servlet 添加初始化参数。配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>detectAllHandlerMappings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置该参数之后，就会走 else 的逻辑，依赖查找一个 HandlerMapping。(前提是在 Spring 配置文件中有配置 HandlerMapping 类型的 Bean，并且只能有一个 HandlerMapping 类型的 Bean，多个的话还是会走默认的配置)。<br>如果经过上面的加载之后， handlerMappings 还没初始化，那么将会通过加载 DispatcherServlet.properties 文件中定义的属性去查找。DispatcherServlet.properties 中定义了三个 HandlerMapping。分别是 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping、RouterFunctionMapping。这三个 HandlerMapping 仅会赋值给 handlerMappings，并不会注册到 WebApplicationContext 中。<br>这里顺便再讲一下 &lt;mvc:annotation-driven/&gt; 与 HandlerMapping 的关系。 &lt;mvc:annotation-driven/&gt;  注解由 AnnotationDrivenBeanDefinitionParser 进行解析，会解析出两个 HandlerMapping 的 Bean 并注册到 WebApplicationContext 中。这两个 Bean 分别是 RequestMappingHandlerMapping(Order 0) 与 BeanNameUrlHandlerMapping(Order 2) 。</p>
<p>handlerMappings 的初始化就完成了。</p>
<h2 id="HandlerMapping-接口"><a href="#HandlerMapping-接口" class="headerlink" title="HandlerMapping 接口"></a>HandlerMapping 接口</h2><p>HandlerMapping 中定义了一个接口方法以及一堆常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String BEST_MATCHING_HANDLER_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingHandler&quot;;</span><br><span class="line">String LOOKUP_PATH = HandlerMapping.class.getName() + &quot;.lookupPath&quot;;</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>getHandler 方法定义了通过该方法，可以根据 request 找到一个 HandlerExecutionChain。 HandlerExecutionChain 中有三个比较重要的成员变量，<strong>handler</strong>，<strong>interceptors</strong>，<strong>interceptorList</strong>。其中 interceptorList 与 interceptors 是一致的，一个以数组的形式存储，另一个以 List 的形式存储。handler 则是当前 HandlerExecutionChain 的执行器。此外，HandlerExecutionChain 还定义了四个执行 HandlerInterceptor 的方法。</p>
<p>HandlerMapping 的类结构图如下图所示，后续将对每一个实现类进行分析。</p>
<p><img src="http://ww1.sinaimg.cn/large/9be02752gy1gl2vroydvcj20rs0ae436.jpg" alt="HandlerMapping.png"></p>
<p>可以看到 AbstractHandlerMapping 有三个直接实现，分别是 AbstractHandlerMethodMapping， AbstractUrlHandlerMapping， 以及 RouterFunctionMapping。</p>
<h3 id="AbstractHandlerMapping"><a href="#AbstractHandlerMapping" class="headerlink" title="AbstractHandlerMapping"></a>AbstractHandlerMapping</h3><p>AbstractHandlerMapping 实现了 Ordered 接口以及 BeanNameAware 接口，使得其具有将 HandlerMapping 排序以及设置 BeanName 的能力。 AbstractHandlerMapping 是 HandlerMapping 接口的抽象实现。在该抽象实现中，使用了几个工具，比如 UrlPathHelper、 PathMatcher、 CorsConfigurationSource。 UrlPathHelper 用于对 URL 进行处理， PathMatcher 用于对 path 的匹配条件判断， CorsConfigurationSource 则是与跨域问题相关的。有兴趣的可以去查阅相关资料。</p>
<p>先看下 getHandler 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="comment">// 如果找不到，则使用默认的</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="comment">// 如果是 string 类型，则去依赖查找 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取拦截器链</span></span><br><span class="line">    <span class="comment">// 将 handler 也会封装进 HandlerExecutionChain 中</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractHandlerMapping#getHandler 是 HandlerMapping 中定义的接口方法。其主要逻辑调用了模板方法 AbstractHandlerMapping#getHandlerExecutionChain 来寻找 handler， 由子类实现。如果找到的 handler 为 String 类型，则还需要通过依赖查找，找到其真实的类型。最后将 handler 封装成 HandlerExecutionChain 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 HandlerExecutionChain</span></span><br><span class="line">    <span class="comment">// 如果 handler 已经是 HandlerExecutionChain 类型，则直接用</span></span><br><span class="line">    HandlerExecutionChain chain = (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler));</span><br><span class="line">    <span class="comment">// 获取查找的路径</span></span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class="line">    <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="keyword">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">        <span class="comment">// 如果是 MappedInterceptor 类型，则需要匹配查找路径是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line">            <span class="comment">// 只有匹配了才会被加入到 chain 中</span></span><br><span class="line">            <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="keyword">this</span>.pathMatcher)) &#123;</span><br><span class="line">                chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接加入到 chain 中</span></span><br><span class="line">            chain.addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装的过程中将 adaptedInterceptors 中的 Interceptor 加入到该 HandlerExecutionChain 中，如果是 MappedInterceptor， 还需要判断是否满足 MappedInterceptor 中配置的匹配条件。</p>
<h2 id="RouterFunctionMapping"><a href="#RouterFunctionMapping" class="headerlink" title="RouterFunctionMapping"></a>RouterFunctionMapping</h2><p>RouterFunctionMapping 是 Spring 5.2 引入的新的 HandlerMapping 。 留到以后再分析吧….</p>
<h2 id="AbstractUrlHandlerMapping-及其子类"><a href="#AbstractUrlHandlerMapping-及其子类" class="headerlink" title="AbstractUrlHandlerMapping 及其子类"></a>AbstractUrlHandlerMapping 及其子类</h2><p>AbstractUrlHandlerMapping 一般情况请求都对应到一个处理类上，处理类需要实现 Controller 接口。<br>主要看下 AbstractUrlHandlerMapping#getHandlerInternal 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的 path，最后一个 / 后面的路径，带 /</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">// 设置仅 request 中</span></span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="comment">// 根据 lookupPath 和 请求查找 handler</span></span><br><span class="line">    <span class="comment">// 得到的 handler 添加了 两个 interceptor</span></span><br><span class="line">    Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">        <span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">        Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是访问根目录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(lookupPath)) &#123;</span><br><span class="line">            <span class="comment">// 返回 rootHandler</span></span><br><span class="line">            <span class="comment">// 单独处理</span></span><br><span class="line">            rawHandler = getRootHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rawHandler = getDefaultHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">            <span class="comment">// 如果是 string 类型，则依赖查找</span></span><br><span class="line">            <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String handlerName = (String) rawHandler;</span><br><span class="line">                rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line">            validateHandler(rawHandler, request);</span><br><span class="line">            <span class="comment">// 这里会给 handler 注册两个 interceptor</span></span><br><span class="line">            handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取到请求的路径，并且将请求路径设置到 request 的属性中去。</li>
<li>通过 AbstractUrlHandlerMapping#lookupHandler 查找 handler。下面看 lookupHandler 方法。</li>
<li>如果没有找到 handler，会有兜底策略。首先如何请求路径是 “/“，则获取 root handler。否则获取默认的 handler。最后还会为当前 handler 关联的 HandlerExecutionChain 添加两个 intercaptors。PathExposingHandlerInterceptor 以及 UriTemplateVariablesHandlerInterceptor。</li>
</ol>
<p>下面看下 AbstractUrlHandlerMapping#lookupHandler 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Direct match?</span></span><br><span class="line">    <span class="comment">// 查找预先配置的请求与该请求对应的处理器</span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">        <span class="comment">// 如果是 String 类型</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String handlerName = (String) handler;</span><br><span class="line">            <span class="comment">// 依赖查找 handler</span></span><br><span class="line">            handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证 handler</span></span><br><span class="line">        validateHandler(handler, request);</span><br><span class="line">        <span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pattern match?</span></span><br><span class="line">    <span class="comment">// 路径匹配</span></span><br><span class="line">    List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历 map 中保存的所有的 路径</span></span><br><span class="line">    <span class="keyword">for</span> (String registeredPattern : <span class="keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 如果匹配请求路径</span></span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">            <span class="comment">// 加到目标 List 中</span></span><br><span class="line">            matchingPatterns.add(registeredPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是否后缀模式匹配</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">            <span class="comment">// 路径加上 / 后进行匹配</span></span><br><span class="line">            <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">&quot;/&quot;</span>, urlPath)) &#123;</span><br><span class="line">                <span class="comment">// 如果匹配也加入到 matchingPatterns 中</span></span><br><span class="line">                matchingPatterns.add(registeredPattern + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// matchingPatterns 中可能有多个，需要找到最佳匹配</span></span><br><span class="line">    String bestMatch = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 排序规则</span></span><br><span class="line">    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">        matchingPatterns.sort(patternComparator);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; matchingPatterns.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Matching patterns &quot;</span> + matchingPatterns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取第一个</span></span><br><span class="line">        bestMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bestMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据找到的最佳匹配获取 handler</span></span><br><span class="line">        handler = <span class="keyword">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bestMatch.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// handlerMap 中的 key 去掉 / 再尝试查找</span></span><br><span class="line">                handler = <span class="keyword">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还找不到就抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Could not find handler for best pattern match [&quot;</span> + bestMatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">        <span class="comment">// 如果 handler 是 String 类型</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String handlerName = (String) handler;</span><br><span class="line">            <span class="comment">// 依赖查找</span></span><br><span class="line">            handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">        validateHandler(handler, request);</span><br><span class="line">        String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);</span><br><span class="line">        <span class="comment">// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables</span></span><br><span class="line">        <span class="comment">// for all of them</span></span><br><span class="line">        Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 前面虽然排序得到第一个，但是第二个以及后续的可能与第一个是相等的</span></span><br><span class="line">        <span class="comment">// 处理有多个匹配相同的情况</span></span><br><span class="line">        <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">            <span class="comment">// 如果相等</span></span><br><span class="line">            <span class="keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提取路径中的模板数据</span></span><br><span class="line">                Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">                <span class="comment">// 将 vars 中的 value 进行编码，根据 request 的编码格式</span></span><br><span class="line">                Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">                <span class="comment">// 放进 uriTemplateVariables 中</span></span><br><span class="line">                uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; uriTemplateVariables.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;URI variables &quot;</span> + uriTemplateVariables);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No handler found...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先查询 handlerMap ，也就是查看是否存在预先定义的请求与处理关系。 handlerMap 是能够保存具有通配符(*)的请求路径，并且能对通配符进行处理。</li>
<li>如果在 handlerMap 中找到了。如果 handler 是 String 类型，则会通过依赖查找到对应的 Bean。随后调用 validateHandler 方法对找到的 handler 进行验证。 validateHandler 方法留给子类实现。 SpringMVC 中提供的实现类均没有重写该验证方法。随后调用 AbstractUrlHandlerMapping#buildPathExposingHandler 方法。</li>
<li>如果没有在 handlerMap 中找到。说明没有预先定义请求与处理关系，或者 handlerMap 中保存的请求路径中有通配符，需要对通配符进行处理后再匹配。<ol>
<li>遍历 handlerMap 中的所有 key，进行匹配，如果匹配上了，则保存到 matchingPatterns 中。匹配的规则由 PathMatcher 定义，PathMatcher 的具体实现类是 AntPathMatcher。</li>
<li>如果还是匹配不上，那么只能返回 null 了。说明 AbstractUrlHandlerMapping 是匹配不到了，只能通过另外的 HandlerMapping 去匹配。</li>
<li>如果匹配上了，并且有多个，那么需要排个序，找出排序后的第一个路径(String) 作为最佳匹配。</li>
<li>根据找到的最佳匹配去 handlerMap 中查找对应的 Handler。</li>
</ol>
</li>
</ol>
<h3 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h3><p>AbstractUrlHandlerMapping 维护了一个 handlerMap 用来保存请求路径与 handler 的关系，SimpleUrlHandlerMapping 中维护了一个 urlMap，做了同样的事情。<br>需要注意的是， SimpleUrlHandlerMapping 对应的 HandlerAdapter 为 SimpleControllerHandlerAdapter。因此处理定义在 handlerMap 中的请求对应的 handler 需要实现 org.springframework.web.servlet.mvc.Controller 接口。</p>
<h3 id="AbstractDetectingUrlHandlerMapping"><a href="#AbstractDetectingUrlHandlerMapping" class="headerlink" title="AbstractDetectingUrlHandlerMapping"></a>AbstractDetectingUrlHandlerMapping</h3><p>AbstractDetectingUrlHandlerMapping 继承了 AbstractUrlHandlerMapping 抽象类。主要看下 AbstractDetectingUrlHandlerMapping#detectHandlers 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">    <span class="comment">// 把所有的 Bean 都查出来了</span></span><br><span class="line">    String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">            <span class="comment">// 依赖查找，包括祖先容器中的 bean</span></span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">            <span class="comment">// 依赖查找，当前容器中的 bean</span></span><br><span class="line">            applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line">    <span class="comment">// Take any bean name that we can determine URLs for.</span></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">// 当前 beanName 关联的 urls</span></span><br><span class="line">        <span class="comment">// 根据 beanName 去关联 urls</span></span><br><span class="line">        String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">            <span class="comment">// URL paths found: Let&#x27;s consider it a handler.</span></span><br><span class="line">            <span class="comment">// 注册 urls 与 beanName 的对应关系</span></span><br><span class="line">            registerHandler(urls, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((logger.isDebugEnabled() &amp;&amp; !getHandlerMap().isEmpty()) || logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Detected &quot;</span> + getHandlerMap().size() + <span class="string">&quot; mappings in &quot;</span> + formatMappingName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在当前上下文中查找出所有的 Bean。</li>
<li>根据 beanName 去关联能够处理的 Url， Url 可能有多个。determineUrlsForHandler 有子类实现。</li>
<li>将 找到的 urls 与 handler 进行注册，注册到 handlerMap 中。</li>
</ol>
<p>随后继续看下子类 BeanNameUrlHandlerMapping#determineUrlsForHandler 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        urls.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取别名</span></span><br><span class="line">    String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            urls.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 WebApplicationContext 容器初始化的时候，会遍历所有的 bean，如果遍历到的 beanName 是以 / 开头的，那么会将该 Bean 的 beanName 以及该 Bean 对应的对象存入到 handlerMap 中。也就是说，请求的路径是 beanName 的时候，会调用该 beanName 对应的 对象(也可以成为处理器) 来进行处理。同样，该 bean 也是需要实现 org.springframework.web.servlet.mvc.Controller 接口的。因为根据 handler 寻找 handlerAdapter 的时候同样需要调用 HandlerAdapter 的 support 方法来判断 HandlerAdapter 是否支持使用该 Handler 来进行处理。</p>
<h2 id="AbstractHandlerMethodMapping-及其子类"><a href="#AbstractHandlerMethodMapping-及其子类" class="headerlink" title="AbstractHandlerMethodMapping 及其子类"></a>AbstractHandlerMethodMapping 及其子类</h2><p>与 AbstractUrlHandlerMapping 不同的是， AbstractHandlerMethodMapping 以一个方法作为 handler。AbstractHandlerMethodMapping 有两个子类，分别是 RequestMappingHandlerMapping 以及  RequestMappingInfoHandlerMapping。与获取 HandlerMethod 相关的主线逻辑还是在 AbstractHandlerMethodMapping 中的，所以两个字类就不展开分析了，有兴趣可以去我的 Github 的相应 repo 下查看源码注释。的同样先看下 AbstractHandlerMethodMapping#getHandlerInternal 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到请求的路径</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">// 设置到 request 中</span></span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="comment">// 请求锁</span></span><br><span class="line">    <span class="comment">// mappingRegistry 中持有一个读写锁</span></span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 path 和 request 获取到 HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="comment">// 如果 handlerMethod 中的 handler 为 String 类型，则找到其真实类型。</span></span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先还是获取到请求的路径。</li>
<li>随后获取读锁，说明 mappingRegistry 在注册的时候，是不能够获取 Handler 的。</li>
<li>随后根据 path 去查找 HandlerMethod。</li>
</ol>
<p>看下 AbstractUrlHandlerMapping#lookupHandlerMethod 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取匹配条件</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到的条件保存到 matches 中</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 默认获取第一个作为 bestMatch</span></span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果有多个</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">            <span class="comment">// 排序</span></span><br><span class="line">            matches.sort(comparator);</span><br><span class="line">            <span class="comment">// 获取第一个</span></span><br><span class="line">            bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果第二个与第一个相同，则抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                String uri = request.getRequestURI();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前请求的 bestMatchingHandler 属性</span></span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无匹配</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先提前介绍一下比较重要的三个 map：</p>
<ul>
<li>urlLookup： 保存了 url 与 RequestMappingInfo 的对应关系。</li>
<li>mappingLookup：保存了 RequestMappingInfo 与 handlerMethod 的关系。</li>
<li>nameLookup：</li>
</ul>
<p>继续上面的方法的分析：</p>
<ol>
<li>先通过 url 查找 mappingRegistry#urlLookup 注册的请求路径与 RequestMappingInfo 的对应关系(在启动的时候会初始化该对应关系)，保存在 directPathMatches 中。可能会有多个，一个路径可能有多个处理方法，比如请求方法是不同的。也可能查找不到，比如带有 @PathVariable 的请求路径不会保存在 urlLookup 关系中。</li>
<li>如果找到了对应关系<ol>
<li>将找到的封装成 Match。</li>
</ol>
</li>
<li>如果找不到对应的关系，一般情况为 handlerMethod 中存在 @PathVariable 参数<ol>
<li>去 mappingRegistry#mappingLookup 对应关系中继续查找。</li>
<li>通过遍历所有的 RequestMappingInfo 去 match request。 match 的逻辑在 RequestMappingInfo#getMatchingCondition 方法中。最后返回 match 的 RequestMappingInfo。并添加到 matches 列表中。</li>
<li>获取 matches 列表中的第一个，即为最佳匹配。如果 matchers 列表中存在大于 1 个，则需要根据规则排序后取第一个。详细逻辑这里就不展开了，可以自己去 debug 源码。</li>
<li>随后调用 RequestMappingInfoHandlerMapping#handleMatch 对 request 进行处理。在 handleMatch 中会对请求路径中的参数提取出来保存到 map 中。 并设置到 request 的 uriTemplateVariables 属性中。</li>
<li>最后返回找到的 HandlerMethod。</li>
<li>如果在 mappingLookup 中依然没有找到匹配的。则会调用 RequestMappingInfoHandlerMapping#handleNoMatch 方法。一般情况下会返回 null。对应页面上显示的就是 404。</li>
</ol>
</li>
</ol>
<p>回到上面的 AbstractHandlerMethodMapping#getHandlerInternal 方法，如果找到了 HandlerMethod，还会调用 HandlerMethod#createWithResolvedBean 方法，该方法的唯一作用就是如果 HandlerMethod 中的 handler 是 String 类型，则通过依赖查找，把真正的类型找出来。</p>
<p>至此，寻找 Handler 的相关方法也已经分析完了。整体来说还有很多细节需要去写的，鉴于控制下文章篇幅，一些匹配的方法就没展开分析了。有兴趣小伙伴可以去深入 debug。</p>
<p>下一篇 HandlerAdapter 见~</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/21/SpringMVC-%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2/" rel="prev" title="SpringMVC 在一个请求中扮演的角色">
      <i class="fa fa-chevron-left"></i> SpringMVC 在一个请求中扮演的角色
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerAdapter/" rel="next" title="SpringMVC 组件-HandlerAdapter">
      SpringMVC 组件-HandlerAdapter <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HandlerMapping-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">HandlerMapping 的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HandlerMapping-%E6%8E%A5%E5%8F%A3"><span class="nav-text">HandlerMapping 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractHandlerMapping"><span class="nav-text">AbstractHandlerMapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouterFunctionMapping"><span class="nav-text">RouterFunctionMapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractUrlHandlerMapping-%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="nav-text">AbstractUrlHandlerMapping 及其子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SimpleUrlHandlerMapping"><span class="nav-text">SimpleUrlHandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractDetectingUrlHandlerMapping"><span class="nav-text">AbstractDetectingUrlHandlerMapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractHandlerMethodMapping-%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="nav-text">AbstractHandlerMethodMapping 及其子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-text">推荐阅读</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FFYzz"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FFYzz</p>
  <div class="site-description" itemprop="description">在自我鄙视中一步一步往上爬</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/FFYzz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;FFYzz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cryptochen95@gmail.com" title="E-Mail → mailto:cryptochen95@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FFYzz</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://littleF.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://ffyzz.github.io/2020/11/21/SpringMVC-%E7%BB%84%E4%BB%B6-HandlerMapping/";
    this.page.identifier = "2020/11/21/SpringMVC-组件-HandlerMapping/";
    this.page.title = "SpringMVC 组件-HandlerMapping";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://littleF.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
